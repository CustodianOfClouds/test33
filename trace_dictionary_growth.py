#!/usr/bin/env python3
"""
Trace what happens to dictionary when next_code check is removed
Shows that decoder adds DEAD ENTRIES that are never used
"""

print("="*80)
print("DETAILED TRACE: What happens WITHOUT the check")
print("="*80)
print()

print("Setup: max-bits=9, so:")
print("  - max_size = 512")
print("  - EVICT_SIGNAL = 511")
print("  - Alphabet codes: 0-255")
print("  - EOF: 256")
print("  - Dictionary entries: 257-510")
print()

print("="*80)
print("PHASE 1: Dictionary filling (next_code = 257 to 510)")
print("="*80)
print()

print("Iteration N:")
print("  1. Read codeword = 100 (some code)")
print("  2. Decode: current = dictionary[100]")
print("  3. Output: current")
print("  4. Add new entry: dictionary[next_code] = prev + current[0]")
print("     -> dictionary[257] = 'ab'")
print("  5. next_code++ -> 258")
print()

print("... many iterations later ...")
print()

print("Iteration M (next_code reaches 511):")
print("  1. Read codeword = 200")
print("  2. Decode: current = dictionary[200]")
print("  3. Output: current")
print("  4. Add new entry: dictionary[511] = prev + current[0]")
print("     -> dictionary[511] = 'xyz'  # Uses code 511!")
print("  5. next_code++ -> 512")
print()

print("="*80)
print("PHASE 2: Dictionary FULL (next_code = 512, 513, 514...)")
print("="*80)
print()

print("Iteration K (dictionary full, encoder sends EVICT_SIGNAL):")
print("  1. Read codeword = 511 (EVICT_SIGNAL)")
print("  2. Check: codeword == EVICT_SIGNAL? YES")
print("  3. Read evict_code = 300 (encoder chose to evict this)")
print("  4. Read new_entry = 'newdata'")
print("  5. Overwrite: dictionary[300] = 'newdata'")
print("  6. **continue** - SKIP rest of loop, go to next iteration")
print("     -> dictionary[next_code] NOT executed!")
print("     -> next_code stays at 512")
print()

print("Iteration K+1 (normal code after EVICT_SIGNAL):")
print("  1. Read codeword = 200 (normal code)")
print("  2. Decode: current = dictionary[200]")
print("  3. Output: current")
print()
print("  4. WITHOUT CHECK:")
print("     dictionary[512] = prev + current[0]")
print("     next_code++ -> 513")
print("     -> ADDS DEAD ENTRY at 512!")
print()
print("  4. WITH CHECK:")
print("     if next_code < EVICT_SIGNAL: (512 < 511 is FALSE)")
print("     -> Skip add")
print("     -> next_code stays at 512")
print()

print("="*80)
print("THE KEY INSIGHT")
print("="*80)
print()

print("Encoder NEVER sends codes >= 512!")
print()
print("Encoder's code space:")
print("  - 0-255: alphabet")
print("  - 256: EOF")
print("  - 257-510: dictionary entries")
print("  - 511: EVICT_SIGNAL (special)")
print("  - 512+: NEVER USED")
print()

print("So WITHOUT check:")
print("  Decoder creates: dictionary[512], dictionary[513], dictionary[514], ...")
print("  But encoder NEVER sends these codes!")
print("  -> DEAD ENTRIES: created but never accessed")
print()

print("WITH check:")
print("  Decoder stops at 511, matching encoder")
print("  -> Clean: no dead entries")
print()

print("="*80)
print("VERIFICATION")
print("="*80)
print()

print("Why does it WORK without check?")
print("  Because dictionary[512], [513], etc. are never looked up!")
print("  Decoder only looks up codes that encoder sends (0-511)")
print()

print("Why is it MESSY without check?")
print("  - Wasted memory (dead entries)")
print("  - Wasted CPU (creating unused entries)")
print("  - next_code grows unbounded: 512, 513, 514, 515, ...")
print("  - In C/C++: potential integer overflow")
print()

print("="*80)
